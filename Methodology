# Testing Methodology for Culpeo #


# Basic Setup #

* Use "synthetic harvested energy circuit"-- a buck regulator on a PCB powered
by 3.3V from the control MCU launchpad to output ~2.1V across a 1k resistor
for a trickle charge effect.

* Put a relay between between the charging circuit and the P_in pin on the power
system.

* Re-route V_out from the output booster to the scary PCB with all of the
Resistor-Transistor circuits.

* TODO: thorough description of the Frankenstein-ing that happened

# Test Capacitor Bank ESR #

These tests are run by hand using the electronic load (BK Precision 9600
electronic load) and they determine the capacitor bank's ESR over a range of
frequencies.  You use the BK to generate a [load] pulse train that the capacitor
bank will handle.

* Turn on the saleae, drop the config down so only the analog V_cap line is
being measured using 125e3 samples/sec. Set it up to measure for 35 seconds, no
Trigger

* Disconnect the control MCU from the enable pin on the power system

* Connect the +/- leads from the BK to V_cap and ground.

* Compile the control MCU code with the no flags. This will ensure that
the control MCU will only charge up when you press the button.

`make clean; make all `

* Configure in the BK external trigger source. Page 44 of the
 [manual](https://bkpmedia.s3.amazonaws.com/downloads/manuals/en-us/8600_Series_manual.pdf)

* Set up the BK for Transient operation. Follow the manual's instructions
starting on page 51 (65 of the pdf) of the manual, and hit the trigger so it's
just ticking in the backgroun.  We're going for continuous mode on the following
load settings:

Level A (mA), Level B (mA), frequency (Hz), duty cycle (%), [seconds on]
1, 5, 0.1, 90, [1]
1, 10, 0.1, 90, [1]
1, 25, 0.1, 90, [1]
1, 5, 0.1, 99, [.1]
1, 10, 0.1, 99, [.1]
1, 25, 0.1, 99, [.1]
1, 50, 0.1, 99, [.1]
1, 5, 0.1, 99.9, [.01]
1, 10, 0.1, 99.9, [.01]
1, 25, 0.1, 99.9, [.01]
1, 50, 0.1, 99.9, [.01]
1, 10, 0.1, 99.99, [.001]
1, 25, 0.1, 99.99, [.001]
1, 50, 0.1, 99.99, [.001]

* For each pulse setting, let the control MCU charge up the capacitor bank, then
start the saleae and hit "On/Off" to get the load started.  Once the saleae is
finished measuring (or the capacitor voltage is clearly too low and it's
bottoming out), hit "On/Off" again to turn off the load. Export the whole saleae
trace as a csv with the following naming convention:

`vcap_<level A>--<level B>mA_10s_<duty cycle*>_duty_cycle_<repeat>.csv`

For example: `vcap_1--25mA_10s_99-9_duty_cycle_0.csv`

*use - instead of . to get to decimal places

* Each run will grab 3 or 4 discharges, so you only need to run each test once

# Analyze capacitor bank ESR *

This part just rusn the files generated from the last phase through a script to
pick out the voltage rebound, and uses the known load to calculate esr. Quick
note- the naming convention from above is important!

* Run the measurement_calcs.py script for a blob of files:

`python3 measurement_calcs.py vcap_*10s_90_* `

* For each trace, this script outputs a couple of plots.  The plots show v_cap
over time as well as the first derivative of vcap that will be used to find
the dips in Vcap.

* Tweak the REBOUND_SECS, SPACING, and LOW_LIM parameters if it doesn't seem
like the right ESR is being reported.

* If V_cap bottoms out (goes to approximately zero and is flat for a while), you
need to toss that datapoint-- you won't get an actual ESR from that.

* Run measurement calcs for each of the duty cycle values, and use the average
ESR for the next step [that really needs to get automated]

# Run V_safe_calculations #
* Note: this step only works without re-capturing the current traces if the
output is 2.56!

* Replace the esr values in esrs.py (it's the esrs dictionary right near the top
of the file) with the esrs calculated in the last step.

* Run the script twice, once with VMIN=1.6 and once with VMIN=1.8, on the
expt_<id>.csv files These live on the google drive in the shared folder
Culpeo--ESR problems/hw_expts/expt_baselines

`python3 esrs.py expt_*`

* This will output a bunch of files with different \#define V_safe adc values
for each experiment. At the moment, those have to be copy-pasted by hand into a
vsafe.h file and placed in the Vsafe_<system name> directories in hw_expts;
that process could totally be improved.  Main thing to remember is that
V_min=1.8V corresponds to CONFIG=0 in the hw_expts directory, and 1.6 is
CONFIG=1

* TODO: make the esrs.py run both Vmin levels and directly place the output in
the correct directory. Also add Makefile flags to switch between power systems

# Run Culpeo Experiments #

* Re-attach the booster enable from the control MCU to the DUT

* Make sure the output of the booster is going from the DUT to the V_in+ of the
diff amp setup. (This connection is kinda loose on Capybara)

* Make sure the power supply for the diff amp is turned on

* Make sure the electronic load is disconnected from Vcap

* Hypothetically you should just be able to run from the hw_expts directory at
this point:

`cd hw_expts; python3 vsafe_test.py`

* You should probably edit the expt_ids list to drop 1) the experiments that
require a V_safe higher than V_HIGH, and 2) catnap experiments that start
below V_min. 

* This writes files to ./expt_output_traces

# Analyze Culpeo Experiments #

* Pass blobs of files to expt_process.py to report the failures under different
conditions. For instance: 

`python3 expt_process.py hw_expts/expt_output_traces/EXPT*_1_*culpeo* `


# Application tests

* An important thing to keep in mind is that you program a Capybara/M4 with the
program under test before queuing up the launchpad to run the harness around
it. The harness will just keep the system on for the correct number of a
seconds-- a program that actually does the workload needs to be programmed on
separately.
* For apps tested externally, (TEST_EXTERNAL) a sip switch will be flipped and
activate the other board.
* The ML on M4 tests use the application in the
camaroptera/src/arm-dnn-accelerator directory set the DVFS setting to 3 (24MHz)
* The LoRa test uses the application in camaroptera/src/loraTest.c from the
Abstract github, you compile
it with the Makefile in that directory. 
* The BLE tests is hacked on the beginning of main_sensors_jit.c from
pacarana_mezzo_tests (it'll need to get ported somewhere real) you build it by just
compiling with USE_SENSORS=1
* The apds test is in main_apds_alone.c in pacarana_mezzo_tests and uses the version
of libapds in that repo. Build it by setting USE_SENSORS=0 RUN_APDS_SOLO=1 The
apds needs to be run twice to get the Vcap and current curves because you can't
put the anmeter setup in there with harvested energy and still maintain a high
enough voltage for the apds i2c to work.  So run it once on harvested energy and
measure Vcap, then run it on continuous power to get the current trace.

# Extracting ESR and calculating Vsafe for real traces:

* Use esr_estimate.py, it'll run the calculations for a trace and spit return
 vsafe.h that needs to be parsed out into separate vsafe directories

 * The way it works is the script cuts off in rush current from the sip switches
 (it's not as bad in real life with incoming energy), then it smoothes out the
 trace and figures out the peak width. It feeds the width through the esr log
 fit to produce an esr.

 * The esr and current trace are used to estimate vsafe on the original (albeit
 clipped) trace.  MAKE SURE YOU DON'T ACCIDENTALLY WRITE OUT THE CALCULATION
 USING THE FILTERED TRACE-- that'll change the amplitude

* As a warning, there are old Vsafe values running around from before when 1.8
was accidentally set as the Vmin instead of 1.6. Double check vsafe.h values
with the new ones.


# Running scheduler tests

* For the scheduler test with the M4:
  * Disconnect the op-amp (I think)
  * Program the harness launchpad with code in: culpeo_sims/hw_expts
  DO_INTERRUPT_TEST , press button on P5.6 to start the interrupts, they'll
  run forever
  * Program a capybara that will act as the front end AND back endwith:
  pacarana_mezzo_tests/main_culpeo.c, USE_SENSORS=0 RUN_CULPEO=1 DO_INTERRUPT=1 APP=2 SCHEDULER=0/1
  * then w/ and w/out #define FULL_RECHARGE
  * Program the m4 with: culpeo_sims/digitTest/ , set the DVFS setting in digitTest/Core/Src/main.c to DVFS_5
  * Then attach the power pins between the capybara and the m4: Vdd --> SIP input, SIP output --> M4 JP6, IDD side
  * Then attach the control pins between the launchpad and capybara: launchpad P3.1 --> capybara P1.4
  * Then attach the pins between the capybara front end and the m4: P1.1 to sip enable, P1.3 --> M4 D7
  * Watch P1.0 on the front end capybara as an indicator of captured interrupts
  * To make this work we powered an op-amp connected to vcap with the launchpad
  to measure vcap

* to plot: run the following from vogar:~/culpeo_sims/plotting_scripts

python3 plot_apds_traces.py results/case_study/apds_30s_clean_charge-to-full.csv \
results/case_study/apds_30s_clean_catnap.csv \
results/case_study/apds_60s_clean_culpeo.csv \



